(window.webpackJsonp=window.webpackJsonp||[]).push([[86],{312:function(e,r,t){"use strict";t.r(r);var a=t(0),v=Object(a.a)({},(function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"浏览器原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器原理","aria-hidden":"true"}},[e._v("#")]),e._v(" 浏览器原理")]),e._v(" "),t("blockquote",[t("blockquote",[t("p",[t("a",{attrs:{href:"https://juejin.im/post/5c6d3e026fb9a04a0d576f98",target:"_blank",rel:"noopener noreferrer"}},[e._v("传送门"),t("OutboundLink")],1),e._v(" "),t("a",{attrs:{href:"https://segmentfault.com/a/1190000020372713?utm_source=tag-newest",target:"_blank",rel:"noopener noreferrer"}},[e._v("春松们"),t("OutboundLink")],1)])])]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E2%80%94%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"}},[e._v("前置知识—进程和线程")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84-%E5%8E%9F%E7%90%86%E7%AF%87"}},[e._v("浏览器架构-原理篇")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84-%E5%AE%9E%E8%B7%B5%E7%AF%87"}},[e._v("浏览器架构-实践篇")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E4%B8%AD%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0%E7%9A%84%E7%9F%AD%E7%9F%AD%E5%87%A0%E7%A7%92%E5%86%85%E6%B5%8F%E8%A7%88%E5%99%A8%E7%A9%B6%E7%AB%9F%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"}},[e._v("在浏览器地址栏中输入url到页面展现的短短几秒内浏览器究竟做了什么？")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8-%E6%B5%81%E7%A8%8B%E6%A6%82%E5%86%B5"}},[e._v("浏览器内核-流程概况")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#window.opener%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"}},[e._v("window.opener安全问题")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E"}},[e._v("文件上传漏洞")])])]),e._v(" "),t("h3",{attrs:{id:"前置知识—进程和线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前置知识—进程和线程","aria-hidden":"true"}},[e._v("#")]),e._v(" 前置知识—进程和线程")]),e._v(" "),t("h4",{attrs:{id:"进程（任务）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#进程（任务）","aria-hidden":"true"}},[e._v("#")]),e._v(" 进程（任务）")]),e._v(" "),t("ul",[t("li",[e._v("An image （与程序相关联的可执行机器代码）")]),e._v(" "),t("li",[e._v("内存")]),e._v(" "),t("li",[e._v("Operating system descriptors分配的资源")]),e._v(" "),t("li",[e._v("安全属性")]),e._v(" "),t("li",[e._v("CPU的上下文")])]),e._v(" "),t("p",[e._v("因为安全性和可靠性，现代操作系统不允许进程之间直接通讯，采用了一种严格的通讯方法叫做 IPC （Inter-process communication）。")]),e._v(" "),t("p",[e._v("多任务的操作系统存在多个进程同时执行，单核CPU一次性只能执行一个进程，CPU进行切换任务，不必等待上一个任务执行结束。")]),e._v(" "),t("p",[e._v("通常，程序中的主程序只有单个进程和多个子进程。")]),e._v(" "),t("h4",{attrs:{id:"线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程","aria-hidden":"true"}},[e._v("#")]),e._v(" 线程")]),e._v(" "),t("ul",[t("li",[e._v("线程是最小的一系列程序指令。")]),e._v(" "),t("li",[e._v("线程是进程中的一个部分。")]),e._v(" "),t("li",[e._v("多线程可以存在一个进程中，并发执行和共享资源。")])]),e._v(" "),t("h4",{attrs:{id:"进程-vs-线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#进程-vs-线程","aria-hidden":"true"}},[e._v("#")]),e._v(" 进程 vs 线程")]),e._v(" "),t("ul",[t("li",[e._v("进程之间是独立的，而线程是进程的子集")]),e._v(" "),t("li",[e._v("进程中状态信息比线程多，然而一个进程中的多线程共享着和进程一样的状态信息")]),e._v(" "),t("li",[e._v("进程有独立的地址空间，线程只是分享进行的地址空间")]),e._v(" "),t("li",[e._v("进程通讯依据系统提供的IPC方法")]),e._v(" "),t("li",[e._v("上下文切换而言，线程切换比进程快")])]),e._v(" "),t("h3",{attrs:{id:"浏览器架构-原理篇"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器架构-原理篇","aria-hidden":"true"}},[e._v("#")]),e._v(" 浏览器架构-原理篇")]),e._v(" "),t("p",[e._v("当代现有的浏览器主要由"),t("code",[e._v("用户界面（The user interface）")]),e._v("、"),t("code",[e._v("浏览器引擎（The browser engine）")]),e._v("、"),t("code",[e._v("呈现引擎（The rendering engine）")]),e._v("、"),t("code",[e._v("网络（Networking）")]),e._v("、"),t("code",[e._v("JavasScript 解释器（JavaScript interpreter）")]),e._v("、"),t("code",[e._v("用户界面后端（UI backend）")]),e._v("、"),t("code",[e._v("数据存储组成（Data storage）")]),e._v("。")]),e._v(" "),t("p",[e._v("而这些组件的功能如下：")]),e._v(" "),t("ol",[t("li",[e._v("用户界面 - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。")]),e._v(" "),t("li",[e._v("浏览器引擎 - 在用户界面和呈现引擎之间传送指令。")]),e._v(" "),t("li",[e._v("渲染引擎 - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。")]),e._v(" "),t("li",[e._v("网络 - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。")]),e._v(" "),t("li",[e._v("用户界面后端 - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。")]),e._v(" "),t("li",[e._v("JavaScript 解释器。用于解析和执行 JavaScript 代码。")]),e._v(" "),t("li",[e._v("数据存储。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。")])]),e._v(" "),t("h3",{attrs:{id:"浏览器架构-实践篇"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器架构-实践篇","aria-hidden":"true"}},[e._v("#")]),e._v(" 浏览器架构-实践篇")]),e._v(" "),t("p",[e._v("chrome有哪些主要进程吧。")]),e._v(" "),t("ul",[t("li",[e._v("Browser Process：浏览器的主进程（负责协调、主控），只有一个。\n"),t("ul",[t("li",[e._v("负责包括地址栏，书签栏，前进后退按钮等部分的工作；")]),e._v(" "),t("li",[e._v("负责各个页面的管理，创建和销毁其他进程；")]),e._v(" "),t("li",[e._v("将Renderer进程得到的内存中的Bitmap，绘制到用户界面上；")]),e._v(" "),t("li",[e._v("负责处理浏览器的一些不可见的底层操作，比如网络请求和文件访问；")])])]),e._v(" "),t("li",[e._v("Renderer Process：默认每个Tab页面一个进程，互不影响。\n"),t("ul",[t("li",[e._v("页面渲染，脚本执行，事件处理等")])])]),e._v(" "),t("li",[e._v("Plugin Process：每种类型的插件对应一个进程，仅当使用该插件时才创建")]),e._v(" "),t("li",[e._v("GPU Process：最多一个，用于3D绘制等")])]),e._v(" "),t("h3",{attrs:{id:"在浏览器地址栏中输入url到页面展现的短短几秒内浏览器究竟做了什么？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#在浏览器地址栏中输入url到页面展现的短短几秒内浏览器究竟做了什么？","aria-hidden":"true"}},[e._v("#")]),e._v(" 在浏览器地址栏中输入url到页面展现的短短几秒内浏览器究竟做了什么？")]),e._v(" "),t("p",[e._v("整个浏览器中的主进程是Browser Process，而进程中会有不同的线程，所以该进程将不同的任务交给不同的线程处理：")]),e._v(" "),t("ul",[t("li",[e._v("UI thread：控制浏览器上的按钮及输入框")]),e._v(" "),t("li",[e._v("network thread：处理网络请求，从网上获取数据")]),e._v(" "),t("li",[e._v("storage thread：控制文件等的访问")])]),e._v(" "),t("p",[e._v("这样的操作在浏览器看来可以分为以下几步：")]),e._v(" "),t("ol",[t("li",[e._v("处理输入\nUI thread 需要判断用户输入的是 URL 还是 query。")]),e._v(" "),t("li",[e._v("开始导航\n当用户点击回车，UI thread 通知 Network thread 获取网页内容，同时控制 tab 上的 spinner 展示（逆时针），表示正在请求页面。")])]),e._v(" "),t("p",[e._v("Network thread 会按照顺序查询 DNS，随后为请求简历 TLS （傳輸層安全性協定：Transport Layer Security）连接。")]),e._v(" "),t("p",[e._v("如果 Network thread 接收到了重定向的请求头如 301，Network thread 会通知 UI thread： 服务器要求重定向了，随后，另一个 URL 请求会被触发。")]),e._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[e._v("读取响应\n当请求响应回来，Network thread 会依据文档的 Content-type 及 MIME Type sniffing 判断响应内容的格式。")])]),e._v(" "),t("p",[e._v("如果响应内容的格式是 HTML，下一步将会把对应的文档交给 Renderer process，如果是 zip文件或是其它文件，会把相关数据传输给下载管理器。")]),e._v(" "),t("p",[e._v("Safe Browsing 检查也会在此时触发，如果域名或是请求内容匹配到已知的恶意站点，Network thread 会展示一个警告页。此外 CORB 检测也会触发确保敏感数据不会被传递 Renderer process。")]),e._v(" "),t("ol",{attrs:{start:"4"}},[t("li",[e._v("查看渲染进程\n当上述检查完成，Network thread 确信浏览器可以导航到请求的网页，Network thread 会通知 UI thread 数据已经准备好了，UI thread 会查找到一个 Renderer process进行网页的渲染。")])]),e._v(" "),t("blockquote",[t("p",[e._v("由于网络请求获取响应需要时间，这里其实还存在着一个加速方案。当 UI thread 发送 URL 请求给 network thread 时，浏览器其实已经知道了将要导航到那个站点。UI thread 会并行的预先查找和启动一个渲染进程，如果一切正常，当 network thread 接收到数据时，渲染进程已经准备就绪了，但是如果遇到重定向，准备好的渲染进程也许就不可用了，这时候就需要重启一个新的渲染进程。")])]),e._v(" "),t("ol",{attrs:{start:"5"}},[t("li",[t("p",[e._v("确认导航\n完成了上述过程，数据和渲染进行都是准备状态，Browser Process 会给 Renderer Process 发送 IPC 消息来确认导航，一旦 Browser Process 收到 renderer process 的渲染确认消息，导航过程结束，页面加载过程开始（ UI thread 通知 tab 的 spinner 展示（顺时针））。\n此时，地址栏会更新，展示出新页面的网页信息。history tab 会更新，可通过返回键返回导航来的页面，为了让关闭 tab 或者窗口后便于恢复，这些信息会存放在硬盘中。")])]),e._v(" "),t("li",[t("p",[e._v("额外的步骤\n导航被确认，Renderer Processs 会使用相关的资源将页面渲染出来。当 Renderer Process 渲染结束（即触发所以页面的onload事件），会发送 IPC 消息到 Browser Process，然后 UI thread 停止展示 tab 中的 spinner。")])])]),e._v(" "),t("h3",{attrs:{id:"浏览器内核-流程概况"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器内核-流程概况","aria-hidden":"true"}},[e._v("#")]),e._v(" 浏览器内核-流程概况")]),e._v(" "),t("blockquote",[t("p",[e._v("负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。")])]),e._v(" "),t("p",[e._v("从定义中得出，其主要核心作用是将请求内容显示在浏览器的窗口中。而我们知道请求内容的种类较多，但是渲染引擎默认展示是 HTML 文档、XML 文档和图片，再有插件支持的情况下方可支持其他的资源，如 pdf等类。")]),e._v(" "),t("h4",{attrs:{id:"主流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#主流程","aria-hidden":"true"}},[e._v("#")]),e._v(" 主流程")]),e._v(" "),t("p",[e._v("起先将请求的内容转化为 8Kb 的 chunks，之后开始解析 HTML 文档构建 DOM 树 ->解析样式结合DOM 树构建 render tree -> 布局（layout） -> 绘制（painting）。")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("render tree")]),e._v("：每一个节点都是一个带有可视化样式和尺寸信息的矩形，节点按照正确的顺序去排列展示的。")]),e._v(" "),t("li",[t("code",[e._v("layout")]),e._v("：该部分目的就是计算出每一个节点的在屏幕上正确的位置。")]),e._v(" "),t("li",[t("code",[e._v("painting")]),e._v("：遍历 render tree，在用户界面后端（UI Backend layer）的帮助下绘制每一个节点。")])]),e._v(" "),t("p",[e._v("整个流程是一个逐渐的过程，为了更好的用户体验，需要尽快的展示内容，所以在浏览器不会等所有的HTML解析完，才开始构建和布局 render tree，这是同步线性进行的流程。这就说明内容会在解析和展示的同时，有其余内容还在网络处理中。")]),e._v(" "),t("h3",{attrs:{id:"【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？","aria-hidden":"true"}},[e._v("#")]),e._v(" 【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？")]),e._v(" "),t("pre",[t("code",[e._v('答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。\n\n其中ACK报文是用来应答的，SYN报文是用来同步的。\n\n但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，\n\n所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。\n\n只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。\n\n故需要四步握手\n')])]),e._v(" "),t("h3",{attrs:{id:"【问题2】为什么time-wait状态需要经过2msl-最大报文段生存时间-才能返回到close状态？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#【问题2】为什么time-wait状态需要经过2msl-最大报文段生存时间-才能返回到close状态？","aria-hidden":"true"}},[e._v("#")]),e._v(" 【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？")]),e._v(" "),t("pre",[t("code",[e._v("答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，\n\n有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。\n\n在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。\n\n所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。\n\nClient会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。\n\n所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，\n\n2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，\n\n那么Client推断ACK已经被成功接收，则结束TCP连接。\n")])]),e._v(" "),t("h3",{attrs:{id:"【问题3】为什么不能用两次握手进行连接？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#【问题3】为什么不能用两次握手进行连接？","aria-hidden":"true"}},[e._v("#")]),e._v(" 【问题3】为什么不能用两次握手进行连接？")]),e._v(" "),t("pre",[t("code",[e._v("答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，\n\n也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。\n\n现在把三次握手改成仅需要两次握手，死锁是可能发生的。\n\n作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，\n\n并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。\n\n可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，\n\nC甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分组，\n\n只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。\n")])]),e._v(" "),t("h3",{attrs:{id:"【问题4】如果已经建立了连接，但是客户端突然出现故障了怎么办？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#【问题4】如果已经建立了连接，但是客户端突然出现故障了怎么办？","aria-hidden":"true"}},[e._v("#")]),e._v(" 【问题4】如果已经建立了连接，但是客户端突然出现故障了怎么办？")]),e._v(" "),t("pre",[t("code",[e._v("TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。\n\n服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，\n\n若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。\n\n若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。\n")])])])}),[],!1,null,null,null);r.default=v.exports}}]);