(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{303:function(a,e,t){"use strict";t.r(e);var s=t(0),r=Object(s.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"浏览器缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存","aria-hidden":"true"}},[a._v("#")]),a._v(" 浏览器缓存")]),a._v(" "),t("h3",{attrs:{id:"浏览器缓存基本认识"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存基本认识","aria-hidden":"true"}},[a._v("#")]),a._v(" 浏览器缓存基本认识")]),a._v(" "),t("p",[a._v("它分为强缓存和协商缓存：")]),a._v(" "),t("ol",[t("li",[t("p",[a._v("浏览器在加载资源时，先根据这个资源的一些http header判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。")])]),a._v(" "),t("li",[t("p",[a._v("当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源；")])]),a._v(" "),t("li",[t("p",[a._v("当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。")])])]),a._v(" "),t("p",[a._v("强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。")]),a._v(" "),t("h3",{attrs:{id:"强缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#强缓存","aria-hidden":"true"}},[a._v("#")]),a._v(" 强缓存")]),a._v(" "),t("p",[a._v("当浏览器对某个资源的请求命中了强缓存时，返回的http状态为200，在chrome的开发者工具的network里面size会显示为from cache，比如京东的首页里就有很多静态资源配置了强缓存，用chrome打开几次，再用f12查看network，可以看到有不少请求就是从缓存中加载的：")]),a._v(" "),t("p",[a._v("强缓存可以通过设置两种 HTTP Header 实现："),t("code",[a._v("Expires")]),a._v(" 和 "),t("code",[a._v("Cache-Control")]),a._v(" ，它们都用来表示资源在客户端缓存的有效期，"),t("code",[a._v("state code 为 200")]),a._v("。")]),a._v(" "),t("h4",{attrs:{id:"expires"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#expires","aria-hidden":"true"}},[a._v("#")]),a._v(" Expires")]),a._v(" "),t("div",{staticClass:"language-http line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-http"}},[t("code",[t("span",{pre:!0,attrs:{class:"token header-name keyword"}},[a._v("Expires:")]),a._v(" Wed, 22 Oct 2018 08:41:00 GMT\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("p",[t("code",[a._v("Expires")]),a._v("是 "),t("code",[a._v("HTTP/1.0")]),a._v(" 的产物，表示资源会在"),t("code",[a._v("Wed, 22 Oct 2018 08:41:00 GMT")]),a._v("(用GMT格式的字符串表示,由服务器返回，受限于本地时间)后过期，需要再次请求。并且 Expires 如果修改了本地时间，可能会造成缓存失效。")]),a._v(" "),t("p",[a._v("它的"),t("strong",[a._v("缓存原理")]),a._v("是：")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在"),t("code",[a._v("respone的header加上Expires的header")])])]),a._v(" "),t("li",[t("p",[a._v("浏览器在接收到这个资源后，会把"),t("code",[a._v("这个资源连同所有response header一起缓存下来")]),a._v("（所以缓存命中的请求返回的header"),t("code",[a._v("并不是来自服务器")]),a._v("，而是来自"),t("code",[a._v("之前缓存的header")]),a._v("）；")])]),a._v(" "),t("li",[t("p",[a._v("浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的Expires跟当前的请求时间比较，如果请求时间在Expires指定的时间之前，就能命中缓存，否则就不行。")])]),a._v(" "),t("li",[t("p",[a._v("如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header在重新加载的时候会被更新。")])])]),a._v(" "),t("h4",{attrs:{id:"cache-control"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cache-control","aria-hidden":"true"}},[a._v("#")]),a._v(" Cache-Control")]),a._v(" "),t("div",{staticClass:"language-http line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-http"}},[t("code",[t("span",{pre:!0,attrs:{class:"token header-name keyword"}},[a._v("Cache-control:")]),a._v(" max-age=30\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("p",[t("code",[a._v("Cache-Control")]),a._v("是 "),t("code",[a._v("HTTP/1.1")]),a._v("的产物，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示。")]),a._v(" "),t("p",[t("strong",[a._v("优先级高于 Expires")]),a._v(" 。该属性值表示资源会在 30 秒后过期，需要再次请求。")]),a._v(" "),t("p",[a._v("它的"),t("strong",[a._v("缓存原理")]),a._v("是：")]),a._v(" "),t("p",[a._v("1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在"),t("code",[a._v("respone的header加上Cache-Control的header")])]),a._v(" "),t("p",[a._v("2）浏览器在接收到这个资源后，会把"),t("code",[a._v("这个资源连同所有response header")]),a._v("一起缓存下来；")]),a._v(" "),t("p",[a._v("3）浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它"),t("code",[a._v("第一次的请求时间和Cache-Control设定的有效期")]),a._v("，计算出一个"),t("code",[a._v("资源过期时间")]),a._v("，再拿这个"),t("code",[a._v("过期时间")]),a._v("跟"),t("code",[a._v("当前的请求时间")]),a._v("比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。")]),a._v(" "),t("p",[a._v("4）如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header在"),t("code",[a._v("重新加载的时候会被更新")]),a._v("。")]),a._v(" "),t("h3",{attrs:{id:"强缓存的管理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#强缓存的管理","aria-hidden":"true"}},[a._v("#")]),a._v(" 强缓存的管理")]),a._v(" "),t("p",[a._v("通常有2种方式来设置是否启用强缓存：")]),a._v(" "),t("p",[a._v("1）通过代码的方式，在web服务器返回的响应中添加Expires和Cache-Control Header；")]),a._v(" "),t("p",[a._v("2）通过配置web服务器的方式，让web服务器在响应资源的时候统一添加Expires和Cache-Control Header。")]),a._v(" "),t("p",[a._v("比如在javaweb里面，我们可以使用类似下面的代码设置强缓存：")]),a._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[a._v("java"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("util"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Date")]),a._v(" date "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" java"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("util"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Date")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("    \nresponse"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("setDateHeader")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Expires"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("date"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("getTime")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("20000")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//Expires:过时期限值 ")]),a._v("\nresponse"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("setHeader")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Cache-Control"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"public"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//Cache-Control来控制页面的缓存与否,public:浏览器和缓存服务器都可以缓存页面信息；")]),a._v("\nresponse"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("setHeader")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Pragma"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Pragma"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//Pragma:设置页面是否缓存，为Pragma则缓存，no-cache则不缓存")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br")])]),t("p",[a._v("还可以通过类似下面的java代码设置不启用强缓存：")]),a._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[a._v("response"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("setHeader")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Pragma"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"no-cache"')]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("   \nresponse"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("setDateHeader")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Expires"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("   \nresponse"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("addHeader")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Cache-Control"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"no-cache"')]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//浏览器和缓存服务器都不应该缓存页面信息")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br")])]),t("p",[a._v("nginx和apache作为专业的web服务器，都有专门的配置文件，可以配置expires和cache-control。")]),a._v(" "),t("h3",{attrs:{id:"开发过程中解决强缓存问题的常用方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#开发过程中解决强缓存问题的常用方法","aria-hidden":"true"}},[a._v("#")]),a._v(" 开发过程中解决强缓存问题的常用方法")]),a._v(" "),t("p",[a._v("由于在开发的时候不会专门去配置强缓存，而浏览器又默认会缓存图片，css和js等静态资源，所以开发环境下经常会因为强缓存导致资源没有及时更新而看不到最新的效果，解决这个问题的方法有很多，常用的有以下几种：")]),a._v(" "),t("p",[a._v("1）直接ctrl+f5，这个办法能解决页面直接引用的资源更新的问题；")]),a._v(" "),t("p",[a._v("2）使用浏览器的隐私模式开发；")]),a._v(" "),t("p",[a._v("3）如果用的是chrome，可以f12在network那里把缓存给禁掉（这是个非常有效的方法）：")]),a._v(" "),t("p",[a._v("4）在开发阶段，给资源加上一个动态的参数，如css/index.css?v=0.0001，由于每次资源的修改都要更新引用的位置，同时修改参数的值，所以操作起来不是很方便，除非你是在动态页面比如jsp里开发就可以用服务器变量来解决（v=${sysRnd}），或者你能用一些前端的构建工具来处理这个参数修改的问题；")]),a._v(" "),t("p",[a._v("5）如果资源引用的页面，被嵌入到了一个iframe里面，可以在iframe的区域右键单击重新加载该页面s")]),a._v(" "),t("p",[a._v("6）如果缓存问题出现在ajax请求中，最有效的解决办法就是ajax的请求地址追加随机数；")]),a._v(" "),t("p",[a._v("7）还有一种情况就是动态设置iframe的src时，有可能也会因为缓存问题，导致看不到最新的效果，这时候在要设置的src后面添加随机数也能解决问题；")]),a._v(" "),t("p",[a._v("8）如果你用的是grunt和gulp这种前端工具开发，通过它们的插件比如grunt-contrib-connect来启动一个静态服务器，则完全不用担心开发阶段的资源更新问题，因为在这个静态服务器下的所有资源返回的respone header中，cache-control始终被设置为不缓存：")]),a._v(" "),t("h3",{attrs:{id:"强缓存的应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#强缓存的应用","aria-hidden":"true"}},[a._v("#")]),a._v(" 强缓存的应用")]),a._v(" "),t("p",[a._v("强缓存是前端性能优化最有力的工具，没有之一，对于有大量静态资源的网页，一定要利用强缓存，提高响应速度。通常的做法是，"),t("code",[a._v("为这些静态资源全部配置一个超时时间超长的Expires或Cache-Control")]),a._v("，这样用户在访问网页时，只会在第一次加载时从服务器请求静态资源，其它时候只要缓存没有失效并且用户没有强制刷新的条件下都会从自己的缓存中加载，比如前面提到过的京东首页缓存的资源，它的缓存过期时间都设置到了2026年：")]),a._v(" "),t("p",[a._v("然而这种缓存配置方式会带来一个新的问题，就是发布时资源更新的问题，比如某一张图片，在用户访问第一个版本的时候已经缓存到了用户的电脑上，当网站发布新版本，替换了这个图片时，已经访问过第一个版本的用户由于缓存的设置，导致在默认的情况下不会请求服务器最新的图片资源，除非他清掉或禁用缓存或者强制刷新，否则就看不到最新的图片效果。")]),a._v(" "),t("p",[a._v("强缓存还有一点需要注意的是，通常都是针对静态资源使用，动态资源需要慎用，除了服务端页面可以看作动态资源外，那些引用静态资源的html也可以看作是动态资源，如果这种html也被缓存，当这些html更新之后，可能就没有机制能够通知浏览器这些html有更新，尤其是前后端分离的应用里，页面都是纯html页面，每个访问地址可能都是直接访问html页面，这些页面通常不加强缓存，以保证浏览器访问这些页面时始终请求服务器最新的资源。")]),a._v(" "),t("h3",{attrs:{id:"协商缓存的原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存的原理","aria-hidden":"true"}},[a._v("#")]),a._v(" 协商缓存的原理")]),a._v(" "),t("p",[a._v("当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，"),t("code",[a._v("Response Header")]),a._v("的http状态为"),t("code",[a._v("304")]),a._v("并且会显示一个"),t("code",[a._v("Not Modified")]),a._v("的字符串，比如你打开京东的首页，按f12打开开发者工具，再按f5刷新页面，查看network，可以看到有不少请求就是命中了协商缓存的")]),a._v(" "),t("p",[a._v("协商缓存是利用的是"),t("code",[a._v("【Last-Modified，If-Modified-Since】")]),a._v("和"),t("code",[a._v("【ETag、If-None-Match】")]),a._v("这两对Header来管理的。")]),a._v(" "),t("h4",{attrs:{id:"【last-modified，if-modified-since】"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#【last-modified，if-modified-since】","aria-hidden":"true"}},[a._v("#")]),a._v(" 【Last-Modified，If-Modified-Since】")]),a._v(" "),t("p",[t("code",[a._v("Last-Modified")]),a._v(" 表示"),t("code",[a._v("本地文件最后修改日期")]),a._v("，"),t("code",[a._v("If-Modified-Since")]),a._v(" 会将 Last-Modified 的值发送给服务器，询问服务器在"),t("code",[a._v("该日期后资源")]),a._v("是否有更新，"),t("code",[a._v("有更新的话就会将新的资源发送回来")]),a._v("，"),t("code",[a._v("否则返回 304 状态码")]),a._v("。")]),a._v(" "),t("p",[a._v("1）浏览器第一次跟服务器请求一个资源，服务器在"),t("code",[a._v("返回这个资源的同时")]),a._v("，在"),t("code",[a._v("respone的header")]),a._v("加上"),t("code",[a._v("Last-Modified的header")]),a._v("，这个header表示这个资源在服务器上的"),t("code",[a._v("最后修改时间")]),a._v("：")]),a._v(" "),t("p",[a._v("2）浏览器再次跟服务器请求这个资源时，在"),t("code",[a._v("request的header")]),a._v("上加上"),t("code",[a._v("If-Modified-Since的header")]),a._v("，这个header的值就是"),t("code",[a._v("上一次请求")]),a._v("时返回的"),t("code",[a._v("Last-Modified的值")]),a._v("：")]),a._v(" "),t("p",[a._v("3）服务器再次收到资源请求时，根据浏览器传过来"),t("code",[a._v("If-Modified-Since")]),a._v("和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回"),t("code",[a._v("304 Not Modified，但是不会返回资源内容,response header中不会再添加Last-Modified的header")]),a._v("；如果有变化，就正常返回资源内容。")]),a._v(" "),t("p",[a._v("4）浏览器收到304的响应后，就会从缓存中加载资源。")]),a._v(" "),t("p",[a._v("5）如果协商缓存没有命中，浏览器直接从服务器加载资源时，"),t("code",[a._v("Last-Modified Header在重新加载的时候会被更新")]),a._v("，下次请求时，"),t("code",[a._v("If-Modified-Since")]),a._v("会启用"),t("code",[a._v("上次返回的Last-Modified")]),a._v("值。")]),a._v(" "),t("p",[t("strong",[a._v("但是 "),t("code",[a._v("Last-Modified")]),a._v(" 存在一些弊端:")])]),a._v(" "),t("ul",[t("li",[t("p",[a._v("如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 "),t("code",[a._v("Last-Modified")]),a._v("被修改，服务端不能命中缓存导致发送相同的资源")])]),a._v(" "),t("li",[t("p",[a._v("因为  "),t("code",[a._v("Last-Modified")]),a._v("只能 "),t("code",[a._v("以秒计时")]),a._v("，如果在 "),t("code",[a._v("不可感知的时间内")]),a._v("修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源")])])]),a._v(" "),t("p",[a._v("因为以上这些弊端，所以在  "),t("code",[a._v("HTTP / 1.1")]),a._v("出现了  "),t("code",[a._v("ETag")]),a._v("。")]),a._v(" "),t("h4",{attrs:{id:"【etag、if-none-match】"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#【etag、if-none-match】","aria-hidden":"true"}},[a._v("#")]),a._v(" 【ETag、If-None-Match】")]),a._v(" "),t("p",[t("code",[a._v("ETag")]),a._v(" 类似于文件指纹，"),t("code",[a._v("If-None-Match")]),a._v("会将"),t("code",[a._v("当前 ETag")]),a._v("发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级比 Last-Modified "),t("code",[a._v("高")]),a._v("。")]),a._v(" "),t("p",[a._v("1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在"),t("code",[a._v("respone的header加上ETag的header")]),a._v("，这个header是服务器根据"),t("code",[a._v("当前请求的资源")]),a._v("生成的一个"),t("code",[a._v("唯一标识")]),a._v("，这个唯一标识是一个字符串，只要资源有变化这个串就不同。")]),a._v(" "),t("p",[a._v("2）浏览器再次跟服务器请求这个资源时，在"),t("code",[a._v("request的header上加上If-None-Match的header")]),a._v("，这个header的值就是"),t("code",[a._v("上一次请求")]),a._v("时返回的ETag的值：")]),a._v(" "),t("p",[a._v("3）服务器再次收到资源请求时，根据浏览器传过来If-None-Match和根据资源生成新的ETag比较，如果这两个值相同就说明资源没有变化，"),t("code",[a._v("304 Not Modified，但是不会返回资源内容")]),a._v("，"),t("code",[a._v("response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化")]),a._v("；否则就是有变化，就正常返回资源内容；")]),a._v(" "),t("p",[a._v("4）浏览器收到304的响应后，就会从缓存中加载资源。")]),a._v(" "),t("h3",{attrs:{id:"协商缓存的管理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存的管理","aria-hidden":"true"}},[a._v("#")]),a._v(" 协商缓存的管理")]),a._v(" "),t("p",[a._v("大部分web服务器都默认开启协商缓存，而且是同时启用【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】，比如apache。如果没有协商缓存，每个到服务器的请求，就都得返回资源内容，这样服务器的性能会极差。")]),a._v(" "),t("p",[a._v("【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】一般都是同时启用，这是为了处理Last-Modified不可靠的情况。")]),a._v(" "),t("p",[a._v("有一种场景需要注意：")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败；")])]),a._v(" "),t("li",[t("p",[a._v("分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）；")])])]),a._v(" "),t("h3",{attrs:{id:"浏览器行为对缓存的影响"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器行为对缓存的影响","aria-hidden":"true"}},[a._v("#")]),a._v(" 浏览器行为对缓存的影响")]),a._v(" "),t("p",[a._v("如果资源已经被浏览器缓存下来，在缓存失效之前，再次请求时，默认会先检查是否命中强缓存，如果强缓存命中则直接读取缓存，如果强缓存没有命中则发请求到服务器检查是否命中协商缓存，如果协商缓存命中，则告诉浏览器还是可以从缓存读取，否则才从服务器返回最新的资源。这是默认的处理方式，这个方式可能被浏览器的行为改变：")]),a._v(" "),t("p",[a._v("1）当ctrl+f5强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；")]),a._v(" "),t("p",[a._v("2）当f5刷新网页时，跳过强缓存，但是会检查协商缓存；")]),a._v(" "),t("h3",{attrs:{id:"from-memory-cache-和-from-disk-cache的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#from-memory-cache-和-from-disk-cache的区别","aria-hidden":"true"}},[a._v("#")]),a._v(" from memory cache 和 from disk cache的区别")]),a._v(" "),t("p",[a._v("from memory cache：字面理解是从内存中，其实也是字面的含义，这个资源是直接从内存中拿到的，不会请求服务器一般已经加载过该资源且缓存在了内存当中，当关闭该页面时，此资源就被内存释放掉了，再次重新打开相同页面时不会出现from memory cache的情况")]),a._v(" "),t("p",[a._v("from disk cache：同上类似，此资源是从磁盘当中取出的，也是在已经在之前的某个时间加载过该资源，不会请求服务器但是此资源不会随着该页面的关闭而释放掉，因为是存在硬盘当中的，下次打开仍会from disk cache")]),a._v(" "),t("h3",{attrs:{id:"实际场景应用缓存策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实际场景应用缓存策略","aria-hidden":"true"}},[a._v("#")]),a._v(" 实际场景应用缓存策略")]),a._v(" "),t("h4",{attrs:{id:"频繁变动的资源"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#频繁变动的资源","aria-hidden":"true"}},[a._v("#")]),a._v(" 频繁变动的资源")]),a._v(" "),t("p",[a._v("对于频繁变动的资源，首先需要使用 Cache-Control: no-cache 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。")]),a._v(" "),t("h4",{attrs:{id:"代码文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代码文件","aria-hidden":"true"}},[a._v("#")]),a._v(" 代码文件")]),a._v(" "),t("p",[a._v("这里特指除了 HTML 外的代码文件，因为 HTML 文件一般不缓存或者缓存时间很短。")]),a._v(" "),t("p",[a._v("一般来说，现在都会使用工具来打包代码，那么我们就可以对文件名进行哈希处理，只有当代码修改后才会生成新的文件名。基于此，我们就可以给代码文件设置缓存有效期一年 Cache-Control: max-age=31536000，这样只有当 HTML 文件中引入的文件名发生了改变才会去下载最新的代码文件，否则就一直使用缓存。")])])}),[],!1,null,null,null);e.default=r.exports}}]);