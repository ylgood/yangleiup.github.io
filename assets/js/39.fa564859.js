(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{231:function(v,_,e){"use strict";e.r(_);var t=e(0),l=Object(t.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h2",{attrs:{id:"重绘与回流（又叫重排）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重绘与回流（又叫重排）","aria-hidden":"true"}},[v._v("#")]),v._v(" 重绘与回流（又叫重排）")]),v._v(" "),e("h3",{attrs:{id:"写在前面"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#写在前面","aria-hidden":"true"}},[v._v("#")]),v._v(" 写在前面")]),v._v(" "),e("p",[v._v("在讨论回流与重绘之前，我们要知道：")]),v._v(" "),e("ol",[e("li",[v._v("浏览器使用流式布局模型 (Flow Based Layout)。")]),v._v(" "),e("li",[v._v("浏览器会把HTML解析成DOM，把CSS解析成CSSOM，DOM和CSSOM合并就产生了Render Tree。")]),v._v(" "),e("li",[v._v("有了RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。")]),v._v(" "),e("li",[v._v("由于浏览器使用流式布局，对Render Tree的计算通常只需要遍历一次就可以完成，但table及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用table布局的原因之一。\n"),e("strong",[v._v("一句话：回流必将引起重绘，重绘不一定会引起回流。")])])]),v._v(" "),e("h3",{attrs:{id:"重绘-repaint"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重绘-repaint","aria-hidden":"true"}},[v._v("#")]),v._v(" 重绘(repaint)")]),v._v(" "),e("p",[v._v("当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要 UI 层面的重新像素绘制，因此损耗较少")]),v._v(" "),e("p",[v._v("常见的重绘操作：")]),v._v(" "),e("ol",[e("li",[v._v("改变元素颜色")]),v._v(" "),e("li",[v._v("改变元素背景色")]),v._v(" "),e("li",[v._v("more ……")])]),v._v(" "),e("h3",{attrs:{id:"回流-reflow"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#回流-reflow","aria-hidden":"true"}},[v._v("#")]),v._v(" 回流(reflow)")]),v._v(" "),e("p",[v._v("当元素的尺寸"),e("code",[v._v("、")]),v._v("结构或者触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。")]),v._v(" "),e("p",[v._v("常见的回流操作：")]),v._v(" "),e("ol",[e("li",[v._v("页面初次渲染")]),v._v(" "),e("li",[v._v("浏览器窗口大小改变")]),v._v(" "),e("li",[v._v("元素尺寸/位置/内容发生改变")]),v._v(" "),e("li",[v._v("元素字体大小变化")]),v._v(" "),e("li",[v._v("添加或者删除可见的 DOM 元素")]),v._v(" "),e("li",[v._v("激活 CSS 伪类（:hover……）")]),v._v(" "),e("li",[v._v("查询某些属性或调用某些方法")])]),v._v(" "),e("p",[v._v("一些常用且会导致回流的属性和方法：")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("clientWidth")]),v._v("、"),e("code",[v._v("clientHeight")]),v._v("、"),e("code",[v._v("clientTop")]),v._v("、"),e("code",[v._v("clientLeft")])]),v._v(" "),e("li",[e("code",[v._v("offsetWidth")]),v._v("、"),e("code",[v._v("offsetHeight")]),v._v("、"),e("code",[v._v("offsetTop")]),v._v("、"),e("code",[v._v("offsetLeft")])]),v._v(" "),e("li",[e("code",[v._v("scrollWidth")]),v._v("、"),e("code",[v._v("scrollHeight")]),v._v("、"),e("code",[v._v("scrollTop")]),v._v("、"),e("code",[v._v("scrollLeft")])]),v._v(" "),e("li",[e("code",[v._v("scrollIntoView()")]),v._v("、"),e("code",[v._v("scrollIntoViewIfNeeded()")])]),v._v(" "),e("li",[e("code",[v._v("getComputedStyle()")])]),v._v(" "),e("li",[e("code",[v._v("getBoundingClientRect()")])]),v._v(" "),e("li",[e("code",[v._v("scrollTo()")])])]),v._v(" "),e("h3",{attrs:{id:"如何避免"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何避免","aria-hidden":"true"}},[v._v("#")]),v._v(" 如何避免")]),v._v(" "),e("p",[e("strong",[v._v("CSS")])]),v._v(" "),e("ol",[e("li",[v._v("避免使用table布局。")]),v._v(" "),e("li",[v._v("尽可能在DOM树的最末端改变class。")]),v._v(" "),e("li",[v._v("避免设置多层内联样式。")]),v._v(" "),e("li",[v._v("将动画效果应用到position属性为absolute或fixed的元素上。")]),v._v(" "),e("li",[v._v("避免使用CSS表达式（例如：calc()）")])]),v._v(" "),e("p",[e("strong",[v._v("JavaScript")])]),v._v(" "),e("ol",[e("li",[v._v("避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。")]),v._v(" "),e("li",[v._v("避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。")]),v._v(" "),e("li",[v._v("也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。")]),v._v(" "),e("li",[v._v("避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。")]),v._v(" "),e("li",[v._v("对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。")])])])}),[],!1,null,null,null);_.default=l.exports}}]);